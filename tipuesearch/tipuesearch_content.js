
var tipuesearch = {
     "pages": [
          { "title": "Home", "text": "About: about_image; Ceptre Editor is a web-based program for creating prototypes for games in a conceptual level; it was made as a quicker and more direct way of making experimental game mechanics, without having to code more specific details that the person might not be interested in making at the moment. The Ceptre Editor allows you to build a world and the elements that exist in said world, as well as manipulate how these elements will act and interact with each other. This allows users to be able to start creating a base or a skeleton of a game and see if the mechanics would be possible or what problems arise when trying to make it and, if possible, correct them. It works by looking for arguments that are true in the world and allow the user to execute certain actions accordingly. The same way that many games can be boiled down to a handful of rules and goals, the Ceptre allows developers to discern whether the game that they are conceptualizing could have important pitfalls that they would need to avoid. About Us: Chris Martens : Assistant professor in the Computer Science (CSC) Department at NC State, where they direct the Principles of Expressive Machines (POEM) Lab. Contact Alexander Card : Generative methods and AI for interactive storytelling. Contact Jacqueline Hong : Working on the Ceptre editor website, examples and videos. Contact Happy coding! Logo by: Rook Liu", "url": "https://ceptre-website.herokuapp.com/index.html" },
          { "title": "Ceptre Editor", "text": "Ceptre Editor, Editor, Program", "url": "https://ceptre-website.herokuapp.com/microceptre/index.html" },
          { "title": "Tutorial", "text": "Navigation, tutorial pages, tutorial", "url": "https://ceptre-website.herokuapp.com/tutorial.html" },
          { "title": "Walkthrough", "text": "Step by Step Tutorial. Welcome to the Ceptre Editor Walkthrough! In this page we will be making a simple project so that you can learn how the Ceptre Editor works. This steps will be in chronological order, however you can always experiment with how you are most comfortable with. Let's begin! Editor Tab ep 1: Come up with a concept. To start with, have a concept already in mind. concept Usually this would mean to have an idea of what we want the player to be able to do; the objects, locations, characters and, if necessary, a map of our world. However, trial and error is always an option, especially if you are not familiar with Ceptre. For this case we are going to make a map in which the main character Thomas is trying to escape a castle by collecting some items. In this rough concept we already have an idea of what the rules of this world will be: Thomas will only be able to move from one room to another if the rooms are beside each other and if the entrance is open. We also know which items are needed to be able to advance in the game, where they are and where they will be needed. Finally, we also know what the goal is: Escape the castle. Step 2: Create the elements. Now we will add the elements we saw in the concept into the project. To start with, Navigate to the Editor Tab of the Ceptre Editor [editor_tab_(small)] and locate the Sets. Step1 Select the option to Add a New Set, a dialogue box will appear from the website which will allow us to name it [Note: We cannot add spaces to the names so use the _ to avoid confusion.] A Set is just a group of elements that share or will share a common characteristic or behavior, think of it like semantic fields. To start with this example we will make a Set named elements. In this Set we will add Thomas and the items (The metal key, the golden key and the keypad code). It isn't imperative that we put them together, however in the next sections it will save us time since the way that they behave is very similar. The items will only need to exist within the rooms and be able to interact with Thomas. Step2 We will also add another two Sets called rooms and trapped. Rooms are all the rooms that Thomas will be able to move back and forth as well as interact with the items in them: hallway, home_library, master_bedroom, main_room, road_home. Trapped will be used for rooms that Thomas can't interact with until they can use the respective key: dungeon and secret room. Step 3: Create the Predicates. Step3 Next we will add the Predicates. In simple terms a Predicate are states that can exist in our world, they can be composed of arguments, which are Sets that are involved in said state, and usually indicate how an element will interact with another one. Otherwise it can be an state that exists on it's own. In this example we have 4 Predicates: Locked As the name suggests, this state should represent an element being in a room that they can't get out. It is composed of two arguments: - Element: A character or an item - Trapped: A room that cannot be interacted until Thomas has a key. At This Predicate is similar to the previous one as they both indicate the location of an element, however in this one the elements can move between the rooms. It is composed of two arguments: - Element: A character or an item. - Rooms: The rooms that Thomas will be able to move in and out without the need of a key. Equip In this world we want Thomas to be able to pick up and equip elements that they can use. It is composed of two arguments: - Element: A character or an item. Once we make the rules this element will be Thomas. - Element: A character or an item. Once we make the rules this element will be the items that Thomas can pick up. Adjacent This Predicate will indicate which rooms are beside each other and once we make the Rules it will allows us to make Thomas only be able to move between rooms that are beside each other. It is composed of two arguments, however they are the same Sets: - Rooms: The rooms that Thomas will be able to move in and out without the need of a key. Note: Remember to lock [lock_and_unlock(small)] the Predicates so they can be applicable later. Additionally, if we want to change the Predicates after making the rules they will not change automatically, instead they will be erased so be mindful of the changes we make. Step 4: Create the Rules. step4 Now we will be adding the rules in which our world will be working on. First, navigate to the Add rule button and select it. A new menu should appear. After that select the + to Add a New condition or effect. step5 The way rules work are as follows: * There are some conditions that need to be fulfilled before a Rule can be fired (Executed). * * Conditions are Predicates and need to be organized in a certain way to make the rule applicable. * * The conditions can disappear after the rule is fired, but this isn't mandatory. To delete a condition we only need to check the box under remove * * Rule must have at least one effect. * * We can create variables in the Conditions, but we can't in the Effects. However we can use variables created in Conditions in our Effects. *For this example we will be making 8 rules. In reality it is very unlikely that we will be able to know the exact number of rules that we will be needed, which is when the Trial and Error method will most likely be the most useful. Since the game will begin with Thomas being locked up in the locked_dungeon, it would be best to make the rules in the order the player will most likely need them. As we saw in the map during Step 1, we know that there is a jey Thomas will need to escape the dungeon, so we'll start with that.step6 Pick up metal key This rule requires two Conditions; which, as we covered before, are the Predicates we previously made: - Locked: Thomas (Element) is in the locked dungeon (trapped). - Locked: Metal key (Element) is in the locked dungeon (trapped). Once these conditions are filled, the result of the rule firing would be: - Equip: metal key (Element) Thomas (Element).This should roughly read as Thomas having equipped the metal key. Lastly, check the box beside the second condition. This will make the key disappear from the locked dungeon, since Thomas has already equipped it. Note: At this step we could go ahead to the Initial State tab so we can try and see if our program is working, otherwise we can continue with the walkthrough. Leave dungeon This rule requires two Conditions: - Locked: Thomas (Element) is in the locked dungeon (trapped). - Equip: Metal key (Element) Thomas (Element). This option should only appear after Thomas has equipped the metal key, which is why the predicate equip is in the conditions. Once these conditions are filled, the result of the rule firing would be: - At: Thomas (Element) is in the Hallway (Rooms). The remove box of the first condition should be checked, which should remove Thomas from the locked dungeon after the rule is fired. step7 Move Now we finally create the rule to move Thomas between rooms, as well as use the variable feature of the Ceptre. This rule requires two Conditions: - At: Thomas (Element) is in room L (Rooms). In the second argument of the Predicate we will want to select the option New variable. A new dialogue box will appear and we'll be able to name the Variable and name it as w wish, in this case we can just named it L (to indicate location). A variable means that any element of the set could be filling this field and the rule can still be fired. - Adjacent: L (Rooms) is beside L2 (Rooms). This predicate should indicate that Thomas can't move between rooms that aren't beside each other. In the second argument of this predicate we will also add a new variable. We can, again, name it as we wish. Once these conditions are filled, the result of the rule firing would be: - At: Thomas (Element) is in room L2 (Rooms). In the end we should be able to read this rule as: If Thomas is in room L and room L and room L2 are adjacent, then we can move Thomas to room L2. The remove box of the first condition should be checked, which should remove Thomas from the original room (as they cannot be in two rooms at the same time). Pick up golden key This rule is very similar to the one in the first one, the only difference being that the key is in a different room. It requires two Conditions: - At: Thomas (Element) is in the master bedroom (Rooms). - At: Golden key (Element) is in the master bedroom (Rooms). Once these conditions are filled, the result of the rule firing would be: - Equip: Golden key (Element) Thomas (Element). This should roughly read as Thomas having equipped the golden key. Lastly, check the box beside the second condition. This will make the key disappear from the master bedroom, since Thomas has already equipped it. Enter secret room This rule can be fired after Thomas equips the golden key since we don't want them to be able to enter the secret room without said key. It requires two Conditions: - At: Thomas (Element) is in the the home library (Rooms). - Equip: Golden key (Element) Thomas (Element). Once these conditions are filled, the result of the rule firing would be: - Locked: Thomas (Element) is in the secret room (trapped). Lastly, check the box beside the first condition. This will remove Thomas from the home library and into the secret room, it isn't a cloning room after all. Take keypad code Now, this is the last item Thomas will need to collect to be able to escape. It needs two Conditions: - Locked: Thomas (Element) is in the secret room (trapped) - Locked: Keypad code (Element) is in the secret room (trapped) Once these conditions are filled, the result of the rule firing would be: - Equip: Keypad code (Element) Thomas (Element). And finally, check the box to remove the second condition (this would mean that after the rule is fired the keypad code will disappear from the room as Thomas has equipped it.) Leave secret room This rule is much simpler than the other ones since it only needs Thomas to be in the secret room without any other prerequisite. It needs only one Condition: - Locked: Thomas (Element) is in the secret room (trapped) The result would simply take Thomas back to the home library: - At: Thomas (Element) is in the the master bedroom (Rooms). And lastly, check the box next to the condition to remove it. This would delete Thomas from the secret room. Leave creepy house And with this rule we have reached what would be the end of the game. It needs two Conditions: - At: Thomas (Element) is in the the main room (Rooms). - Equip: Keypad code (Element) Thomas (Element). The result would finally put Thomas on their way home, wherever that is: - At: Thomas (Element) is on their road home (Rooms). And lastly, check the box next to the first condition to remove it, removing Thomas from the creepy house. Initial State Tab Step 5: Initial State description. Now we will be moving to the Initial State Tab [initial_state_tab]. The Initial State is the state of execution our program will begin in. In this example we only have to think of it in two ways: The building of our map, which will most likely stay stagnant. In this case, the rooms (including the locked ones) will not change at all throughout all the playthrough. The first position of our elements. These will change in the playthroughs, but when we start the game again these elements will go back to the position we put them in. In this case, the items and Thomas will all start in specific positions, however they will be moved or mutated in the game. Once we start the game again Thomas and the items will go back to their first positions. With that in mind we will start by making the map. Bringing back the concept we saw in Step 1 and the predicate Adjacent we saw in Step 3: concept  step3 We know which rooms we want to be adjacent to each other, so now we only need to add them into the program. Step 6: Place the map in place. step9 We'll start by adding the adjacent rooms. Since we already have some rules to move into certain places (Locked rooms and the exit) we do not have to add them here; however we do need to add the rest of the rooms since the rule that applies to them uses variables (The Move rule).  First we'll select the button Add Atom. An atom is just the predicate that we will be using for the Initial State.  For this whole step we will be using the Adjacent predicate. Next we will insert the arguments: - Adjacent: Hallway (Rooms) Home library (Rooms). Note: This only means that Thomas will be able to go into the Home library, but not from the Home library to the Hallway. To allow them to go back and forward we need to do this rule again, just switching the arguments. To save time we should also use the button Duplicate Atom [duplicate_atom]; which, as the name suggests, will make a copy of the atom. This way we only have to switch the arguments without having to select the predicate again. step8 We will essentially be repeating this process until the rooms we want to be adjacent are all filled in. At the end we should have: - Adjacent: Hallway (Rooms) Home library (Rooms). - Adjacent: Home library (Rooms) Hallway (Rooms). - Adjacent: Home library (Rooms) Master bedroom (Rooms). - Adjacent: Master bedroom (Rooms) Home library (Rooms). - Adjacent: Master bedroom (Rooms) Main room (Rooms). - Adjacent: Main room (Rooms) Master bedroom (Rooms). Step 7: Place the characters and objects into their Initial State. Similarly to the last step we will be putting all the elements in their place, however we know that we will be able to change their original states (In this case just change their position). Thankfully we will not have to add anything new to this and can just add the atoms the same way we had in the previous step. step10 At the end we should have: - At: Golden key (Element) Master bedroom (Rooms). - Locked: Thomas (Element) Dungeon (Rooms). - Locked: Metal Key (Element) Dungeon (Rooms). - Locked: keypad code (Element) Secret room (Rooms). Execution Tab Step 8: Start execution. step11 Now we can finally start our prototype and see if it works. The first thing we need to do is click on Start Execution, because otherwise the executable rules won't appear in the box in the Execution tab. Once we start the execution, we will also be able to see the atoms that we coded before in the States box. Step 9: Transition box. step12 After we select a rule we have to click the button Execution in order to fire it. Once we fire it the next information will appear in the States window: - The rule that was executed. - The conditions that were in place, which allowed the rule to be fired. - The new effects or the arguments that will appear in the new state. - And, finally, the new state. step13 Now, while we are testing the prototype you should know about Quiescence. Quiescence means that there are no more rules executable, which could mean 1 of 3 things: - We have finished the game successfully (We have won).- We have finished the game unsuccessfully (We have lost). - We have found a bug. A state in which we are stuck and can't take anymore actions, however we also haven't finished the game. The first two states are usually fine and we want the character to be able to reach it; however the third option is one we definitely want to avoid. With that in mind, it is important that we test the prototype to be able to find this bugs so we can fix them. Execute to Quiescence is a useful tool because it picks random action paths until it reaches, as the name says, Quiescence. Since it is random and not logical, the tools allows us to find any Quiescence states that we don't want there to be or else it will give us the end states that we are looking for. step14 On the other hand, we don't always need Quiescence. Some games could go on infinitely, like simulation games that we can repeat tasks and don't really have an end goal. In these cases we don't want there to be any Quiescence. However the button is not as useful because, at the moment of this walkthrough, the website crashes if we click Execute to Quiescence in a game we don't want one there to be. To navigate through this we could make a false state that would create Quiescence and get rid of it when finishing the prototype or we can just avoid using this button. Lastly, we can just set an specific amount of Executions we want there to be and, just like the Execute to Quiescence, it will randomly follow a path, except it will just stop when it reaches the selected amount. This could also be used to avoid the issue of finding Quiescence in a game that should have none from before, as we can just select a high amount of actions we want and if it doesn't reach Quiescence the likelyhoods of there being any decrease dramatically.Step 10: Filter box.step15Lastly, we have the Filter; which allows us to keep track of certain states without have to search for them in every new state. To set up a filter we just click on Add filter group [Add filter group] and the menu from the image will appear. Just like the Atoms, filters are just predicates. However, filters also allow us to add variables. As an example, we can try to keep track of all the unlocked rooms Thomas passes through, so we add the filter:- At: Thomas (Element) L (Rooms). We don't have to put them in every prototype e make, but it's a useful tool if we want to keep track of a specific state or to make the new state easier to understand. Examples Tab step16 If we'd like to see some other examples we can also go to the Examples Tab [examples_tab]. In this tab we can see a list of different examples we can download into our computers and load them into the Ceptre Program. We could also play around with our downloaded copies to see how new mechanics work.", "url": "https://ceptre-website.herokuapp.com/Walkthrough.html" },
          { "title": "Glossary", "text": "Glossary. Welcome to the Ceptre Editor Glossary! In this page you can search for a summarized version of what each section of the Ceptre has and what it does. You are welcome to click on the terms to open an image of the section that it's describing. Let's begin!GeneralLock/Unlock button : To be able to edit code the section should be unlocked, however for it to be applicable in your project it needs to be locked. This of it as an Edit mode.Menu : This allows you to hide of show the selected Menu, it can make it easier to keep track of what you're working on. Delete buttons : This buttons allows you to delete any selected sections or anything the button is beside. Add buttons : This buttons allows you to add to selected sections or anything the button is beside.Editor & Initial State : The Editor and the Initial State must both be filled before being able to execute your project.EditorEditor : The editor is where you build what exists or could happen in your project.Choose File : This button allows you to load the files you were previously working on.Save Program : This button allows you to save the project you are currently working on. The page will remind you to save your projec before you leave, since it does not automatically sae your progress.Add Set+ : Add Set+ allows you to create a new group of elements that will exist in your world.Set name : This menu allows you to locate and navigate the different Sets you’ve created.Add to currently selected Set : This field allows you to add a new element to the Set you have currently selected.Remove element/Set : Remove Set/Element allows you to delete a selected Set or Element.Add Predicates : This allows you to create new predicates, which represent additional information about sets or information which is true or active in the world.Name Predicate : This field allows you to name your predicate.Predicate Arguments : This allows you to select the way the sets will interact between each other.Rules : Rule are the actions or changes that can happen in your world Add Rules : This allows you to add a new Rule Rule Name : This field allows you to name your Rule.Conditions : Conditions are the predicates that need to be true before a rule can take effect. You can also add variables so you don’t have to make multiple rules with the same condition and effect.Remove box : Since Rules represent a mutation of some kind, one of the conditions will most likely need to disappear: To do so you only need to tick the Remove box.Added Effect : The Added Effect is the result of a rule firing. You can’t add new variables in this section but you can use variables that were creates in the section of Conditions.Delete Rule : This allows you to delete a Rule you don’t need anymore.Initial State Initial State : The Initial State is the base in which your program will start or build from. The first section is almost the same as the Editor, however if you want to load a previous document it needs to be compatible with your Editor, otherwise it won’t be able to load.Lock All Atoms : As the name suggests, this button locks and unlocks all atoms at the same time. This allows you to save time so you don’t have to each atom. Locking atoms means that they are applicable in your program and are uneditable.Add Atom : This allows you to add an Atom, which are predicates that are already in place in the world when you start an execution.First Field : This allows you to select a predicate for your atom.Second Field : After you select a Set in the First field new menus appear to select the elements from said Set.Duplicate Atom : This allows you to clone an Atom that already exists.Execution Execution : The Execution allows you to fire the rules on your game and essentially play it through. Transition Box : In this section rules that have their conditions fulfilled will appear. You can select which one you want to be fired.Execute Transition : This allows you to fire a selected rule.Execute To Quiescence : This allows you to execute your code until Quiescence, a state in which no more rules can fire.Auto Execute : You can also select a set amount of executions as long as you add the number into the field.Filter : To make a filter you only need to add the Predicate you want to keep track of. You can also add Variables. You aso don't have to lock Filters.Add Filter Group : This allows you to add a Filter, which helps you keep track of certain transition (Predicate).Add Filter : You can add more than one predicate to your Filter Group.Start Execution : Before you can fire any rules or filter states you need to start running your code, or start your execution. The rules that are fired and the current state of the world will appear in the states. You can also start new ones again after making changes to your project Filter States : All filtered states will appear in this field.Examples Examples : You can download already done projects so you can load them into the Ceptre and explore different ways you can code your project. This projects are editable and you can still download the original from the website. Feel free to change and experiment with the examples. ", "url": "https://ceptre-website.herokuapp.com/glossary.html" },
          { "title": "Video", "text": "video tutorial, video, tutorial", "url": "https://ceptre-website.herokuapp.com/video.html" },
     ]
};